# system_optmizaion_team_project_CS
# 시스템 최적화 팀 프로젝트 - 간호사 스케줄링 문제

## 폴더 트리 구조

```
system_optmizaion_team_project_CS
├── CS
│   ├── 1_CS_org.py
│   ├── 2_CS_minus.py
│   └── 3_CS_plus.py
├── Levy
│   └── Levy_vs_Normal.png
└── SA
    ├── 1_SA_org.py
    ├── 2_SA_minus.py
    └── 3_SA_plus.py
└── README.md
```

### 설명
- **ORG**: 원본 제약 조건이 적용된 알고리즘.
- **minus**: 제약 조건이 완화된 알고리즘.
  - **완화 내용**: 근무 횟수 제한이 더 느슨해지고, 특정 연속 근무 패턴 금지 조건이 일부 제거되었습니다.
    - **근무 횟수 제한 완화**: 예를 들어, 나이트 근무의 최대 횟수가 3회에서 5회로 완화되었습니다.
    - **금지된 패턴 조건 완화**: 3일 연속 나이트 근무 금지가 4일 연속으로 완화되었습니다.
- **plus**: 제약 조건이 강화된 알고리즘.
  - **강화 내용**: 더 엄격한 근무 횟수 제한과 추가적인 금지 패턴이 포함되었습니다. 특히, 3일 연속 근무 제한 조건이 강화되어 추가적인 페널티가 부과됩니다.
    - **근무 횟수 제한 강화**: 나이트 근무의 최대 횟수가 3회에서 2회로 강화되었습니다.
    - **연속 근무 제한 강화**: 2일 연속 나이트 근무 금지 조건 추가.
    - **추가 페널티**: 3일 연속 근무 시 페널티가 기존 1점에서 3점으로 강화되었습니다.

## 의사코드 및 알고리즘 설명

### CS (Cuckoo Search) 알고리즘
1. **초기 둥지 생성**: 무작위로 여러 개의 초기 둥지를 생성합니다.
2. **Levy 비행**을 통해 새로운 둥지를 생성하여 기존 둥지를 대체하거나 업데이트합니다.
3. **비용 평가**를 통해 새로운 둥지가 더 좋은 해인지 판단합니다.
4. **파괴 및 재생성**: 일부 둥지를 무작위로 파괴하고 새로운 둥지로 대체합니다.
5. **반복 종료 조건**: 비용이 0이 되거나 최대 세대 수에 도달하면 알고리즘을 종료합니다.

### SA (Simulated Annealing) 알고리즘
1. **초기 스케줄 생성**: 무작위로 초기 스케줄을 생성합니다.
2. **스케줄 변형**: 무작위로 일부 스케줄을 변경하여 새로운 스케줄을 생성합니다.
3. **비용 평가**: 새로운 스케줄의 비용을 평가하여 기존 스케줄과 비교합니다.
4. **비용 수용 조건**: 더 낮은 비용이면 수용하고, 더 높은 비용이라도 확률적으로 수용할 수 있습니다.
5. **온도 감소**: 반복마다 온도를 낮추며, 낮은 온도에서는 더 나쁜 해를 수용할 확률이 줄어듭니다.
6. **반복 종료 조건**: 비용이 0이 되거나 최대 반복 횟수에 도달하면 알고리즘을 종료합니다.

### Levy 비행 설명

- **Levy_vs_Normal.png**: Levy 비행과 일반적인 무작위 탐색의 비교를 시각적으로 보여주는 이미지입니다. Levy 비행이 더 효과적으로 탐색 공간을 커버하는 데 어떻게 도움이 되는지 설명합니다.

## 논문 출처

- 논문 제목: "Cuckoo search를 이용한 간호사 스케줄링 문제의 효율적인 해결"
- 저자: 우윤희, 한림대학교 대학원
- 지도교수: 고영웅
- 발행연도: 2019
- 논문 경로: [DBpia 링크](https://www.dbpia.co.kr/journal/detail?nodeId=T15115825)
- 저작권: 한림대학교 논문은 저작권에 의해 보호받습니다.

## 결과 및 분석

### 결과 테이블

| 조건          | CS Average Time(s) | CS Average Cost | SA Average Time(s) | SA Average Cost | CS 완화 Average Time(s) | CS 완화 Average Cost | SA 완화 Average Time(s) | SA 완화 Average Cost | CS 강화 Average Time(s) | CS 강화 Average Cost | SA 강화 Average Time(s) | SA 강화 Average Cost |
|---------------|---------------------|----------------|---------------------|----------------|-------------------------|----------------------|-------------------------|----------------------|-------------------------|----------------------|-------------------------|----------------------|
| **1 Week**    | 0.46                | 0              | 0.12                | 0              | 0.18                    | 0                    | 0.06                    | 0                    | 12.97                   | 0                    | 3.07                    | 0                    |
| **2 Weeks**   | 0.82                | 0              | 2.1                 | 0              | 0.42                    | 0                    | 1.21                    | 0                    | 18.81                   | 0                    | 70.6                    | 0.37                 |
| **3 Weeks**   | 1.08                | 0              | 18                  | 0              | 0.51                    | 0                    | 11.98                   | 0                    | 27.46                   | 0                    | 215.36                  | 5.75                 |
| **4 Weeks**   | 1.39                | 0              | 166.15              | 0.15           | 0.59                    | 0                    | 107.95                  | 0.5                  | 30.25                   | 0                    | 206.46                  | 19.96                |

### 결과 그래프

- 아래의 그래프는 각 알고리즘의 평균 실행 시간 및 비용을 시각화한 것입니다. 그래프를 통해 각 조건에서의 성능 차이를 보다 쉽게 비교할 수 있습니다.

#### 평균 실행 시간 그래프

![Average Execution Time Graph](average_execution_time.png)

#### 평균 비용 그래프

![Average Cost Graph](average_cost.png)

위의 그래프는 CS와 SA 알고리즘의 실행 시간 및 비용을 비교하며, 각 조건에 따른 성능을 쉽게 이해할 수 있도록 도와줍니다.


